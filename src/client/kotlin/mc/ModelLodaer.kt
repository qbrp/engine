package org.lain.engine.client.mc

import com.google.gson.GsonBuilder
import com.google.gson.JsonParser
import com.mojang.serialization.JsonOps
import com.mojang.serialization.MapCodec
import net.minecraft.client.item.ItemAsset
import net.minecraft.client.render.item.model.*
import net.minecraft.client.render.model.*
import net.minecraft.client.render.model.json.*
import net.minecraft.client.texture.NativeImage
import net.minecraft.client.texture.SpriteContents
import net.minecraft.client.texture.SpriteDimensions
import net.minecraft.client.texture.atlas.AtlasSource
import net.minecraft.client.texture.atlas.AtlasSourceType
import net.minecraft.client.util.SpriteIdentifier
import net.minecraft.resource.ResourceManager
import net.minecraft.resource.metadata.ResourceMetadata
import net.minecraft.util.Identifier
import net.minecraft.util.JsonHelper
import org.lain.engine.client.EngineClient
import org.lain.engine.client.mixin.resource.JsonUnbakedModelAccessor
import org.lain.engine.client.util.Asset
import org.lain.engine.client.util.identifier
import org.lain.engine.util.EngineId
import org.lain.engine.util.injectValue
import org.slf4j.LoggerFactory
import java.io.File
import java.lang.reflect.Type

sealed class EngineItemAsset {
    data class Generated(val texture: Asset) : EngineItemAsset() {
        val modelId = texture.relative.identifier
            .replaceFirst("tex", "autogen")
    }
    data class File(
        val identifier: String,
        val asset: Asset
    ) : EngineItemAsset()
}

private val LOGGER = LoggerFactory.getLogger("Engine Model Loading")

data class ResourceList(
    val textureAssets: List<Asset>,
    val itemModels: List<Asset>,
    val itemAssets: List<EngineItemAsset.File>,
    val generatedItemAssets: List<EngineItemAsset.Generated>
) {
    val allItemAssets = itemAssets + generatedItemAssets
}

fun findAssets(): ResourceList {
    val resources = injectValue<EngineClient>().resources
    val assets = resources.assets

    val itemsAssets = mutableListOf<EngineItemAsset.File>()
    val itemModels = mutableListOf<Asset>()
    val textures = mutableListOf<Asset>()

    assets.browseAssets { relative, file, packer ->
        if (file.extension == "json") {
            val asset = packer()
            if (file.nameWithoutExtension.endsWith(".asset")) {
                itemsAssets += EngineItemAsset.File(
                    asset.relative.identifier
                        .replace(".asset", ""),
                    asset
                )
            } else {
                itemModels += packer()
            }
        } else if (file.extension == "png") {
            textures += packer()
        }
    }

    val autogenerated = resources.autogenerationItemAssets.textures.mapNotNull {
        EngineItemAsset.Generated(assets.getAsset(it) ?: return@mapNotNull null)
    }

    return ResourceList(
        textures, itemModels, itemsAssets, autogenerated
    )
}

class EngineAtlasSource(val resources: ResourceList) : AtlasSource {
    override fun load(
        resourceManager: ResourceManager,
        regions: AtlasSource.SpriteRegions
    ) {
        resources.textureAssets.forEach { asset ->
            val id = EngineId(asset.relative.identifier)
            regions.add(id) { openSprite(id, asset) }
        }
    }

    override fun getType(): AtlasSourceType = TYPE

    companion object {
        val ID = EngineId("engine")
        val TYPE = AtlasSourceType(MapCodec.unit { EngineAtlasSource(ClientMixinAccess.getResourceList()) })

        fun openSprite(id: Identifier, path: Asset): SpriteContents? {
            val file = path.source.file
            if (!file.exists()) return null
            val input = file.inputStream()
            val nativeImage = NativeImage.read(input)
            val width = nativeImage.width
            val height = nativeImage.height
            val spriteDimensions = SpriteDimensions(width, height)
            return SpriteContents(id, spriteDimensions, nativeImage, ResourceMetadata.NONE)
        }
    }
}

fun handleFileExists(assetPath: Asset): Boolean {
    val file = assetPath.source.file
    val exists = file.exists()
    if (!exists) {
        LOGGER.error("Файл ассета предмета ${file.path} не существует и пропущен")
    }
    return exists
}

// Генерировать модели для ассетов предметов
fun autogenerateModels(
    models: List<EngineItemAsset.Generated>
): Map<Identifier, UnbakedModel> {
    return models.associate { model ->
        val id = EngineId(model.modelId)
        val texture = EngineId(model.texture.relative.identifier)
        val sprite = SpriteIdentifier(EngineAtlasSource.ID, texture)
        id to JsonUnbakedModel(
            GeneratedItemModel.GENERATED,
            listOf(),
            ModelTextures.Textures.Builder()
                .addSprite("layer0", sprite)
                .build(),
            null,
            null,
            null
        )
    }
}

fun File.readSubstitutedIdText(asset: Asset): String {
    return readText()
        .replace("engine:~", "engine:${asset.relativeParent.identifier}")
}

// Открыть модели для ассетов предметов
fun parseEngineModels(
    models: List<Asset>,
): Map<Identifier, JsonUnbakedModel> {
    val map = mutableMapOf<Identifier, JsonUnbakedModel>()
    val gson = JsonUnbakedModelAccessor.`engine$getGson`()
    for (model in models) {
        val file = model.source.file
        val relative = model.relative
        val text = file.readSubstitutedIdText(model)
        if (!handleFileExists(model)) continue

        try {
            val jsonModel = JsonHelper.deserialize(
                gson,
                text,
                JsonUnbakedModel::class.java
            )
            map[EngineId(relative.identifier)] = jsonModel
        } catch (e: Throwable) {
            LOGGER.error("При загрузке модели $relative возникла ошибка", e)
        }
    }
    return map
}

fun parseEngineItemAssets(
    assets: List<EngineItemAsset>,
): Map<Identifier, ItemAsset> {
    val contents = mutableMapOf<Identifier, ItemAsset>()
    for (item in assets) {
        when(item) {
            is EngineItemAsset.File -> {
                val asset = item.asset
                val file = asset.source.file
                val text = file.readSubstitutedIdText(asset)
                if (!handleFileExists(asset)) continue

                try {
                    val itemAsset: ItemAsset? = ItemAsset.CODEC.parse(
                        JsonOps.INSTANCE,
                        JsonParser.parseString(text)
                    )
                        .ifError { error ->
                            LOGGER.error("Couldn't parse item item: {}", error.message())
                        }
                        .result()
                        .orElse(null)

                    if (itemAsset == null) continue

                    contents[EngineId(item.identifier)] = itemAsset
                } catch (e: Throwable) {
                    LOGGER.error("При загрузке ассета предмета ${asset.relativeString} возникла ошибка", e)
                }
            }
            is EngineItemAsset.Generated -> {
                val id = EngineId(item.modelId)
                contents[id] = ItemAsset(
                    BasicItemModel.Unbaked(
                        id,
                        listOf()
                    ),
                    ItemAsset.Properties(false)
                )
            }
        }
    }
    return contents
}